<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FX Dashboard</title>
  <meta name="theme-color" content="#0b1220" />
  <style>
    :root{
      --bg:#0b1220; --card:#111a2e; --text:#e8eefc; --muted:#a9b4d0;
      --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --line:#24314f;
    }
    body{ margin:0; background:var(--bg); color:var(--text);
      font-family:-apple-system,system-ui,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif; }
    header{ padding:16px 16px 6px; }
    h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:.2px;}
    .sub{ color:var(--muted); font-size:12px; margin-top:4px; }
    .wrap{ padding:12px 12px 24px; max-width:980px; margin:0 auto; }
    .grid3{ display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px; }
    @media (min-width:1100px){ .grid3{ grid-template-columns:1fr 1fr 1fr; } }

    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px;
      box-shadow:0 6px 18px rgba(0,0,0,.25); }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .pair{ font-size:14px; font-weight:700; }
    .rate{ font-size:22px; font-weight:800; letter-spacing:.2px; }
    .muted{ color:var(--muted); font-size:12px; }
    .pill{ display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:6px 10px;
      border-radius:999px; border:1px solid var(--line); }
    .pill.good{ border-color: rgba(34,197,94,.5); color:#bbf7d0; }
    .pill.warn{ border-color: rgba(245,158,11,.5); color:#fde68a; }
    .pill.bad{ border-color: rgba(239,68,68,.5); color:#fecaca; }

    .controls{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px; }
    .controls label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input, select, button{
      width:100%; box-sizing:border-box; border-radius:12px; border:1px solid var(--line);
      background:#0f1730; color:var(--text); padding:10px 12px; font-size:14px;
    }
    button{ cursor:pointer; background:#13214a; font-weight:700; }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .btnrow{ display:flex; gap:10px; margin-top:10px; }
    .btnrow button{ width:auto; flex:1; }

    .chartwrap{ margin-top:10px; }
    canvas{ width:100% !important; height:250px !important; }

    .kpi{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .kpi .k{ background:#0f1730; border:1px solid var(--line); border-radius:12px; padding:10px; min-width:150px; }
    .k .v{ font-size:16px; font-weight:800; }
    .k .l{ font-size:11px; color:var(--muted); margin-top:2px; }

    .sim{ margin-top:10px; background:#0f1730; border:1px solid var(--line); border-radius:12px; padding:10px; }
    .sim .title{ font-weight:800; font-size:13px; margin-bottom:6px; }
    .sim .line{ font-size:12px; color:var(--muted); line-height:1.55; }

    .footer{ margin-top:14px; font-size:11px; color:var(--muted); line-height:1.5; }
    a{ color:#9cc2ff; }
  </style>

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>

<body>
  <header>
    <h1>FX Dashboard</h1>
    <div class="sub" id="status">読み込み中…</div>
  </header>

  <div class="wrap">
    <!-- Rules / Holdings -->
    <div class="card">
      <div class="row">
        <div>
          <div class="pair">運用ルール（防衛モード）＋保有額シミュレーション＋クールダウン</div>
          <div class="muted">閾値・分割・手数料・保有額・クールダウンを固定して「迷わない」</div>
        </div>
        <div class="pill" id="ruleSaved">未保存</div>
      </div>

      <div class="controls">
        <div>
          <label>期間（チャート）</label>
          <select id="days">
            <option value="90">90日</option>
            <option value="180" selected>180日</option>
            <option value="365">365日</option>
          </select>
        </div>
        <div>
          <label>判定の閾値（%）</label>
          <input id="threshold" type="number" min="0.5" step="0.5" value="3.0" />
        </div>
        <div>
          <label>分割（条件一致時に動かす割合 %）</label>
          <input id="slicePct" type="number" min="5" step="5" value="25" />
        </div>
        <div>
          <label>移動平均（長期）</label>
          <select id="maLong">
            <option value="60" selected>60日</option>
            <option value="90">90日</option>
          </select>
        </div>

        <div>
          <label>保有：JPY</label>
          <input id="holdJPY" type="number" min="0" step="1000" value="0" />
        </div>
        <div>
          <label>保有：USD</label>
          <input id="holdUSD" type="number" min="0" step="1" value="100" />
        </div>
        <div>
          <label>保有：EUR</label>
          <input id="holdEUR" type="number" min="0" step="1" value="0" />
        </div>
        <div>
          <label>手数料（スプレッド相当 %）</label>
          <input id="spreadPct" type="number" min="0" step="0.05" value="0.30" />
        </div>
        <div>
          <label>クールダウン（日）</label>
          <input id="cooldownDays" type="number" min="0" step="1" value="7" />
        </div>
        <div>
          <label>（予備）</label>
          <input disabled value=" " />
        </div>
      </div>

      <div class="btnrow">
        <button id="save">保存</button>
        <button id="reload">更新</button>
      </div>

      <div class="footer">
        データ：Frankfurter（ECB基準の終値ベース、営業日のみ更新） / 端末保存：localStorage
      </div>
    </div>

    <!-- 3 pairs -->
    <div class="grid3">
      <!-- USD/JPY -->
      <div class="card">
        <div class="row">
          <div>
            <div class="pair">USD/JPY</div>
            <div class="muted" id="usd_date">—</div>
          </div>
          <div class="rate" id="usd_rate">—</div>
        </div>
        <div class="kpi">
          <div class="k"><div class="v" id="usd_dev">—</div><div class="l">長期MA乖離（%）</div></div>
          <div class="k"><div class="v" id="usd_signal">—</div><div class="l">今日の方針</div></div>
          <div class="k"><div class="v" id="usd_action">—</div><div class="l">動かす割合</div></div>
        </div>
        <div class="sim">
          <div class="title">シミュレーション</div>
          <div class="line" id="usd_sim">—</div>
          <div class="btnrow" style="margin-top:10px;">
            <button id="usd_exec">実行した（記録）</button>
          </div>
          <div class="footer" id="usd_cd">—</div>
        </div>
        <div class="chartwrap"><canvas id="usdChart"></canvas></div>
        <div class="footer" id="usd_note"></div>
      </div>

      <!-- EUR/JPY -->
      <div class="card">
        <div class="row">
          <div>
            <div class="pair">EUR/JPY</div>
            <div class="muted" id="eurjpy_date">—</div>
          </div>
          <div class="rate" id="eurjpy_rate">—</div>
        </div>
        <div class="kpi">
          <div class="k"><div class="v" id="eurjpy_dev">—</div><div class="l">長期MA乖離（%）</div></div>
          <div class="k"><div class="v" id="eurjpy_signal">—</div><div class="l">今日の方針</div></div>
          <div class="k"><div class="v" id="eurjpy_action">—</div><div class="l">動かす割合</div></div>
        </div>
        <div class="sim">
          <div class="title">シミュレーション</div>
          <div class="line" id="eurjpy_sim">—</div>
          <div class="btnrow" style="margin-top:10px;">
            <button id="eurjpy_exec">実行した（記録）</button>
          </div>
          <div class="footer" id="eurjpy_cd">—</div>
        </div>
        <div class="chartwrap"><canvas id="eurjpyChart"></canvas></div>
        <div class="footer" id="eurjpy_note"></div>
      </div>

      <!-- EUR/USD -->
      <div class="card">
        <div class="row">
          <div>
            <div class="pair">EUR/USD</div>
            <div class="muted" id="eurusd_date">—</div>
          </div>
          <div class="rate" id="eurusd_rate">—</div>
        </div>
        <div class="kpi">
          <div class="k"><div class="v" id="eurusd_dev">—</div><div class="l">長期MA乖離（%）</div></div>
          <div class="k"><div class="v" id="eurusd_signal">—</div><div class="l">今日の方針</div></div>
          <div class="k"><div class="v" id="eurusd_action">—</div><div class="l">動かす割合</div></div>
        </div>
        <div class="sim">
          <div class="title">シミュレーション</div>
          <div class="line" id="eurusd_sim">—</div>
          <div class="btnrow" style="margin-top:10px;">
            <button id="eurusd_exec">実行した（記録）</button>
          </div>
          <div class="footer" id="eurusd_cd">—</div>
        </div>
        <div class="chartwrap"><canvas id="eurusdChart"></canvas></div>
        <div class="footer" id="eurusd_note"></div>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="pair">読み方（防衛の基本）</div>
      <div class="footer">
        ・乖離が <b>+閾値%</b> 以上：その通貨が“高め”寄り → <b>持ってるなら少し売る（円転/他通貨へ）</b><br/>
        ・乖離が <b>-閾値%</b> 以下：その通貨が“安め”寄り → <b>余力があるなら少し買う</b><br/>
        ・それ以外：<b>何もしない</b>（判断疲れの削減が最大のリターン）
      </div>
    </div>
  </div>

<script>
(() => {
  const API = "https://api.frankfurter.dev/v1";
  const LSKEY = "fxdash_rules_v3";
  const LSEXEC = "fxdash_exec_v1"; // 最終実行日の保存

  // --- helpers ---
  const el = (id) => document.getElementById(id);
  const fmt = (x, d=3) => (x==null || Number.isNaN(x)) ? "—" : Number(x).toFixed(d);

  function mean(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }

  function movingAverage(series, window){
    const out = [];
    const buf = [];
    for (const p of series){
      buf.push(p.v);
      if (buf.length > window) buf.shift();
      out.push(buf.length === window ? mean(buf) : null);
    }
    return out;
  }

  function setPill(node, text, cls){
    node.className = "pill " + (cls || "");
    node.textContent = text;
  }

  function toISO(d){ return d.toISOString().slice(0,10); }

  async function fetchLatest(base, symbolsCsv){
    const url = `${API}/latest?base=${encodeURIComponent(base)}&symbols=${encodeURIComponent(symbolsCsv)}`;
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error("latest fetch failed");
    return r.json();
  }

  async function fetchSeries(base, symbolsCsv, days){
    const end = new Date();
    const start = new Date(end.getTime() - days*24*3600*1000);
    const url = `${API}/${toISO(start)}..${toISO(end)}?base=${encodeURIComponent(base)}&symbols=${encodeURIComponent(symbolsCsv)}`;
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error("series fetch failed");
    return r.json();
  }

  function normalizeSeries(json, symbol){
    const keys = Object.keys(json.rates).sort();
    return keys
      .filter(k => json.rates[k] && typeof json.rates[k][symbol] === "number")
      .map(k => ({ t:k, v: json.rates[k][symbol] }));
  }

  // --- exec (cooldown) storage ---
  function loadExec(){
    try { const raw = localStorage.getItem(LSEXEC); return raw ? JSON.parse(raw) : {}; }
    catch { return {}; }
  }
  function saveExec(obj){
    localStorage.setItem(LSEXEC, JSON.stringify(obj));
  }
  function todayISO(){
    const d = new Date();
    return d.toISOString().slice(0,10);
  }
  function daysBetweenISO(a, b){
    const da = new Date(a + "T00:00:00");
    const db = new Date(b + "T00:00:00");
    return Math.floor((db - da) / (24*3600*1000));
  }
  function cooldownInfo(pairKey, cooldownDays){
    const exec = loadExec();
    const last = exec[pairKey] || null;
    if (!last || cooldownDays <= 0){
      return { inCooldown:false, last:null, remaining:0 };
    }
    const passed = daysBetweenISO(last, todayISO());
    const remaining = Math.max(0, cooldownDays - passed);
    return { inCooldown: remaining > 0, last, remaining };
  }
  function renderCooldown(pairKey, cooldownDays, footerElId, buttonElId){
    const info = cooldownInfo(pairKey, cooldownDays);
    const f = el(footerElId);
    const b = el(buttonElId);
    if (!f || !b) return info;

    if (!info.last){
      f.textContent = "未実行（記録なし）";
      b.disabled = false;
      return info;
    }
    if (info.inCooldown){
      f.textContent = `最終実行: ${info.last} / クールダウン中（残り ${info.remaining} 日）`;
      b.disabled = true;
    } else {
      f.textContent = `最終実行: ${info.last} / クールダウン終了`;
      b.disabled = false;
    }
    return info;
  }
  function bindExecButton(pairKey, buttonElId){
    const b = el(buttonElId);
    if (!b) return;
    b.addEventListener("click", () => {
      const exec = loadExec();
      exec[pairKey] = todayISO();
      saveExec(exec);
      renderAll();
    });
  }

  // --- rules / holdings ---
  const ui = {
    status: el("status"),
    days: el("days"),
    threshold: el("threshold"),
    slicePct: el("slicePct"),
    maLong: el("maLong"),
    holdJPY: el("holdJPY"),
    holdUSD: el("holdUSD"),
    holdEUR: el("holdEUR"),
    spreadPct: el("spreadPct"),
    cooldownDays: el("cooldownDays"),
    save: el("save"),
    reload: el("reload"),
    ruleSaved: el("ruleSaved"),
  };

  function loadRules(){
    try { const raw = localStorage.getItem(LSKEY); return raw ? JSON.parse(raw) : null; }
    catch { return null; }
  }
  function saveRules(r){ localStorage.setItem(LSKEY, JSON.stringify(r)); }

  function readRulesFromUI(){
    return {
      days: Number(ui.days.value),
      thresholdPct: Number(ui.threshold.value),
      slicePct: Number(ui.slicePct.value),
      maLong: Number(ui.maLong.value),
      holdJPY: Number(ui.holdJPY.value),
      holdUSD: Number(ui.holdUSD.value),
      holdEUR: Number(ui.holdEUR.value),
      spreadPct: Number(ui.spreadPct.value),
      cooldownDays: Number(ui.cooldownDays.value),
    };
  }

  function applyRulesToUI(r){
    if (!r) return;
    ui.days.value = String(r.days ?? 180);
    ui.threshold.value = String(r.thresholdPct ?? 3.0);
    ui.slicePct.value = String(r.slicePct ?? 25);
    ui.maLong.value = String(r.maLong ?? 60);
    ui.holdJPY.value = String(r.holdJPY ?? 0);
    ui.holdUSD.value = String(r.holdUSD ?? 100);
    ui.holdEUR.value = String(r.holdEUR ?? 0);
    ui.spreadPct.value = String(r.spreadPct ?? 0.30);
    ui.cooldownDays.value = String(r.cooldownDays ?? 7);
    setPill(ui.ruleSaved, "保存済み", "good");
  }

  // --- decision logic ---
  function classify(devPct, thr){
    if (devPct == null || Number.isNaN(devPct)) return { label:"データ不足", cls:"warn", mode:"none" };
    if (devPct >= thr) return { label:"高め → 少し売る検討", cls:"warn", mode:"sell" };
    if (devPct <= -thr) return { label:"安め → 少し買う検討", cls:"good", mode:"buy" };
    return { label:"何もしない", cls:"good", mode:"hold" };
  }

  // spread model (rough)
  function effSellRate(rate, sPct){ return rate * (1 - sPct/100); }
  function effBuyRate(rate, sPct){ return rate * (1 + sPct/100); }

  // Apply cooldown as a “hard stop” on action:
  // If in cooldown => force hold (but keep the underlying devPct display)
  function applyCooldownToDecision(pairKey, decision, rules){
    const info = cooldownInfo(pairKey, rules.cooldownDays);
    if (info.inCooldown){
      return { ...decision, mode:"hold", label:`クールダウン中 → 何もしない（残り${info.remaining}日）`, cls:"good" };
    }
    return decision;
  }

  function simUSDJPY(rate, decision, rules){
    const s = rules.spreadPct;
    const slice = rules.slicePct / 100;
    const usd = rules.holdUSD;
    const jpy = rules.holdJPY;

    if (decision.mode === "sell"){
      const usdMove = usd * slice;
      const jpyGain = usdMove * effSellRate(rate, s);
      return `USD ${usdMove.toFixed(2)} を円転 → 約 ${Math.round(jpyGain).toLocaleString()} 円（スプレッド ${s}% 想定）`;
    }
    if (decision.mode === "buy"){
      const jpyMove = jpy * slice;
      if (jpyMove <= 0) return `円が0円なので買いシミュレーション不可（保有JPYを入力してね）`;
      const usdGet = jpyMove / effBuyRate(rate, s);
      return `JPY ${Math.round(jpyMove).toLocaleString()} でUSD購入 → 約 ${usdGet.toFixed(2)} USD（スプレッド ${s}% 想定）`;
    }
    return `条件未満 or クールダウン → 取引しない（迷いを減らすのが勝ち）`;
  }

  function simEURJPY(rate, decision, rules){
    const s = rules.spreadPct;
    const slice = rules.slicePct / 100;
    const eur = rules.holdEUR;
    const jpy = rules.holdJPY;

    if (decision.mode === "sell"){
      const eurMove = eur * slice;
      const jpyGain = eurMove * effSellRate(rate, s);
      return `EUR ${eurMove.toFixed(2)} を円転 → 約 ${Math.round(jpyGain).toLocaleString()} 円（スプレッド ${s}% 想定）`;
    }
    if (decision.mode === "buy"){
      const jpyMove = jpy * slice;
      if (jpyMove <= 0) return `円が0円なので買いシミュレーション不可（保有JPYを入力してね）`;
      const eurGet = jpyMove / effBuyRate(rate, s);
      return `JPY ${Math.round(jpyMove).toLocaleString()} でEUR購入 → 約 ${eurGet.toFixed(2)} EUR（スプレッド ${s}% 想定）`;
    }
    return `条件未満 or クールダウン → 取引しない（迷いを減らすのが勝ち）`;
  }

  // EUR/USD: rate = USD per EUR
  function simEURUSD(rate, decision, rules){
    const s = rules.spreadPct;
    const slice = rules.slicePct / 100;
    const eur = rules.holdEUR;
    const usd = rules.holdUSD;

    if (decision.mode === "sell"){
      const eurMove = eur * slice;
      const usdGain = eurMove * effSellRate(rate, s);
      return `EUR ${eurMove.toFixed(2)} をUSDへ → 約 ${usdGain.toFixed(2)} USD（スプレッド ${s}% 想定）`;
    }
    if (decision.mode === "buy"){
      const usdMove = usd * slice;
      if (usdMove <= 0) return `USDが0なので買いシミュレーション不可（保有USDを入力してね）`;
      const eurGet = usdMove / effBuyRate(rate, s);
      return `USD ${usdMove.toFixed(2)} でEUR購入 → 約 ${eurGet.toFixed(2)} EUR（スプレッド ${s}% 想定）`;
    }
    return `条件未満 or クールダウン → 取引しない（迷いを減らすのが勝ち）`;
  }

  // --- charts ---
  let usdChart, eurjpyChart, eurusdChart;

  function makeChart(canvas, labels, price, ma20, maL, longW){
    const ctx = canvas.getContext("2d");
    return new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          { label: "レート", data: price, tension: 0.15, pointRadius: 0 },
          { label: "MA20", data: ma20, tension: 0.15, pointRadius: 0 },
          { label: `MA${longW}`, data: maL, tension: 0.15, pointRadius: 0 },
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: "#a9b4d0" } } },
        scales: {
          x: { ticks: { color: "#a9b4d0", maxTicksLimit: 6 }, grid: { color: "rgba(36,49,79,.35)" } },
          y: { ticks: { color: "#a9b4d0" }, grid: { color: "rgba(36,49,79,.35)" } },
        }
      }
    });
  }

  function updateChart(which, labels, price, ma20, maL, longW){
    const map = {
      usd: { canvas: el("usdChart"), ref: () => usdChart, set: (c)=>usdChart=c },
      eurjpy: { canvas: el("eurjpyChart"), ref: () => eurjpyChart, set: (c)=>eurjpyChart=c },
      eurusd: { canvas: el("eurusdChart"), ref: () => eurusdChart, set: (c)=>eurusdChart=c },
    };
    const slot = map[which];
    const existing = slot.ref();
    if (!existing){
      const ch = makeChart(slot.canvas, labels, price, ma20, maL, longW);
      slot.set(ch);
      return;
    }
    existing.data.labels = labels;
    existing.data.datasets[0].data = price;
    existing.data.datasets[1].data = ma20;
    existing.data.datasets[2].data = maL;
    existing.data.datasets[2].label = `MA${longW}`;
    existing.update();
  }

  // --- render pairs ---
  async function renderUSDJPY(rules){
    const days = rules.days, longW = rules.maLong, thr = rules.thresholdPct;

    const latest = await fetchLatest("USD", "JPY");
    const rate = latest.rates.JPY;
    const latestDate = latest.date;

    const seriesJson = await fetchSeries("USD", "JPY", days);
    const series = normalizeSeries(seriesJson, "JPY");
    const labels = series.map(p=>p.t);
    const price  = series.map(p=>p.v);
    const ma20 = movingAverage(series, 20);
    const maL  = movingAverage(series, longW);
    const lastPrice = price.at(-1);
    const lastMaL = maL.at(-1);
    const devPct = (lastMaL==null) ? null : ((lastPrice-lastMaL)/lastMaL)*100;

    let decision = classify(devPct, thr);
    decision = applyCooldownToDecision("USDJPY", decision, rules);

    el("usd_rate").textContent = fmt(rate, 3);
    el("usd_date").textContent = `更新日: ${latestDate}`;
    el("usd_dev").textContent = (devPct==null) ? "—" : devPct.toFixed(1)+"%";
    el("usd_signal").textContent = decision.label;
    el("usd_action").textContent = `${rules.slicePct}%`;
    el("usd_note").textContent = `長期MA(${longW}日)基準。乖離が ±${thr}% を超えたら分割で動かす（スプレッド ${rules.spreadPct}% / クールダウン ${rules.cooldownDays}日）。`;
    el("usd_sim").textContent = simUSDJPY(rate, decision, rules);

    updateChart("usd", labels, price, ma20, maL, longW);
    return latestDate;
  }

  async function renderEURJPY(rules){
    const days = rules.days, longW = rules.maLong, thr = rules.thresholdPct;

    const latest = await fetchLatest("EUR", "JPY");
    const rate = latest.rates.JPY;
    const latestDate = latest.date;

    const seriesJson = await fetchSeries("EUR", "JPY", days);
    const series = normalizeSeries(seriesJson, "JPY");
    const labels = series.map(p=>p.t);
    const price  = series.map(p=>p.v);
    const ma20 = movingAverage(series, 20);
    const maL  = movingAverage(series, longW);
    const lastPrice = price.at(-1);
    const lastMaL = maL.at(-1);
    const devPct = (lastMaL==null) ? null : ((lastPrice-lastMaL)/lastMaL)*100;

    let decision = classify(devPct, thr);
    decision = applyCooldownToDecision("EURJPY", decision, rules);

    el("eurjpy_rate").textContent = fmt(rate, 3);
    el("eurjpy_date").textContent = `更新日: ${latestDate}`;
    el("eurjpy_dev").textContent = (devPct==null) ? "—" : devPct.toFixed(1)+"%";
    el("eurjpy_signal").textContent = decision.label;
    el("eurjpy_action").textContent = `${rules.slicePct}%`;
    el("eurjpy_note").textContent = `長期MA(${longW}日)基準。乖離が ±${thr}% を超えたら分割で動かす（スプレッド ${rules.spreadPct}% / クールダウン ${rules.cooldownDays}日）。`;
    el("eurjpy_sim").textContent = simEURJPY(rate, decision, rules);

    updateChart("eurjpy", labels, price, ma20, maL, longW);
    return latestDate;
  }

  async function renderEURUSD(rules){
    const days = rules.days, longW = rules.maLong, thr = rules.thresholdPct;

    const latest = await fetchLatest("EUR", "USD");
    const rate = latest.rates.USD;
    const latestDate = latest.date;

    const seriesJson = await fetchSeries("EUR", "USD", days);
    const series = normalizeSeries(seriesJson, "USD");
    const labels = series.map(p=>p.t);
    const price  = series.map(p=>p.v);
    const ma20 = movingAverage(series, 20);
    const maL  = movingAverage(series, longW);
    const lastPrice = price.at(-1);
    const lastMaL = maL.at(-1);
    const devPct = (lastMaL==null) ? null : ((lastPrice-lastMaL)/lastMaL)*100;

    let decision = classify(devPct, thr);
    decision = applyCooldownToDecision("EURUSD", decision, rules);

    el("eurusd_rate").textContent = fmt(rate, 4);
    el("eurusd_date").textContent = `更新日: ${latestDate}`;
    el("eurusd_dev").textContent = (devPct==null) ? "—" : devPct.toFixed(1)+"%";
    el("eurusd_signal").textContent = decision.label;
    el("eurusd_action").textContent = `${rules.slicePct}%`;
    el("eurusd_note").textContent =
      `長期MA(${longW}日)基準。高め→EUR→USD、安め→USD→EUR の分割リバランス（スプレッド ${rules.spreadPct}% / クールダウン ${rules.cooldownDays}日）。`;
    el("eurusd_sim").textContent = simEURUSD(rate, decision, rules);

    updateChart("eurusd", labels, price, ma20, maL, longW);
    return latestDate;
  }

  async function renderAll(){
    ui.status.textContent = "更新中…";
    const t0 = performance.now();
    try{
      const rules = readRulesFromUI();

      // update cooldown UI (button disable + remaining days)
      renderCooldown("USDJPY", rules.cooldownDays, "usd_cd", "usd_exec");
      renderCooldown("EURJPY", rules.cooldownDays, "eurjpy_cd", "eurjpy_exec");
      renderCooldown("EURUSD", rules.cooldownDays, "eurusd_cd", "eurusd_exec");

      const [d1, d2, d3] = await Promise.all([
        renderUSDJPY(rules),
        renderEURJPY(rules),
        renderEURUSD(rules),
      ]);
      const t1 = performance.now();
      ui.status.textContent = `OK（更新日: USD/JPY=${d1}, EUR/JPY=${d2}, EUR/USD=${d3}）・${(t1-t0).toFixed(0)}ms`;
    } catch(e){
      console.error(e);
      ui.status.textContent = "取得に失敗しました（電波状況 or API応答）";
    }
  }

  // init
  const stored = loadRules();
  if (stored) applyRulesToUI(stored);

  // bind exec buttons
  bindExecButton("USDJPY", "usd_exec");
  bindExecButton("EURJPY", "eurjpy_exec");
  bindExecButton("EURUSD", "eurusd_exec");

  ui.save.addEventListener("click", () => {
    const rules = readRulesFromUI();
    saveRules(rules);
    setPill(ui.ruleSaved, "保存済み", "good");
    renderAll();
  });

  ui.reload.addEventListener("click", () => renderAll());

  // mark unsaved on change
  ["days","threshold","slicePct","maLong","holdJPY","holdUSD","holdEUR","spreadPct","cooldownDays"].forEach(id => {
    el(id).addEventListener("change", () => setPill(ui.ruleSaved, "未保存", "warn"));
    el(id).addEventListener("input",  () => setPill(ui.ruleSaved, "未保存", "warn"));
  });

  renderAll();
})();
</script>
</body>
</html>
